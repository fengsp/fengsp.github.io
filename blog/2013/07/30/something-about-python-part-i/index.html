
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>About python: Part I - fengsp blogs</title>
  <meta name="author" content="fengsp">

  
  <meta name="description" content="Python execution In Python, everything is runtime. Everything happens in namespaces, modules classes and functions all have their own namespace. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fengsp.github.io/blog/2013/07/30/something-about-python-part-i">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="fengsp blogs" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">fengsp blogs</a></h1>
  
    <h2>less is less</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fengsp.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">About Python: Part I</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-30T14:51:00+08:00" pubdate data-updated="true">Jul 30<span>th</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Python execution</h2>

<p>In Python, everything is runtime. Everything happens in namespaces, modules classes and functions all have their own namespace. Modules are executed top to bottom, def and class are runtime too.</p>

<p>No basic things like if or for loop statement is going to be mentioned. Let us begin with one class and one function.</p>

<pre><code>class Foo(object):

    def __init__(self):
        self.foo = 'foo'

foo = Foo()
</code></pre>

<p>We have a init function to initialize the class instance, the self argument is implicitly brought in when you call a instance method.</p>

<pre><code>def func(arg1, arg2=foo)
    print "We are inside func"
    def inner_func(arg3=arg2):
        print "entering inner_func"
        return arg1, arg3
    arg1 = arg2 = None
    return inner_func

foo.foo = 'foo2'
arg1, arg2 = func('fsp')()
print arg1, arg2.foo
</code></pre>

<p>So here we are getting None and foo2 as the result, what I want to mention here is that arguments of a function is initialized when the interpreter meets the def thing, once your def is done, everytime you call a function, the arg is actually the same thing. (Something weird might happen as a result of this, by the way, the body block is just compiled but not executed when met.)</p>

<h2>Some basic things</h2>

<p>Variables are names, not containers. Everything is an object, everything is a reference, while variables are neither. Variables refer to objects and namespaces map names to objects. You can use module to organize code, every module is executed on first import, then they are cached in <code>sys.modules</code>. And <code>import</code> is syntactic sugar, which means that <code>mod = __import__("mod")</code>.</p>

<pre><code>os = __import__('os')
print os.path.dirname(__file__)
</code></pre>

<p>So we have python objects, we have the concept of mutability and hashability. We have usual operators, <code>+ * / ** ^ &amp; ~ +=</code>.  You can access the attribute by using <code>obj.attr</code> and access Indexing things by <code>obj[idx]</code>. Calling something is simple, <code>obj(args…)</code>, Iteration is simple too, <code>for item in obj: you logic here</code>. True or False test, <code>if obj:, if item in obj:</code>, Conversions, <code>str(obj)</code>. All per-object data is stored in <code>__dict__</code> attribute and you can refer to class using <code>__class__</code> attribute. What I like most is that you can define your own behavior by overriding the certain <code>__*__</code> method.</p>

<h2>Iterators and Generators</h2>

<p>Iterators have two protocols, <code>__iter__()</code> and <code>next()</code>.</p>

<pre><code>it = iter(range(10))
print zip(it, it)
</code></pre>

<p>Generators is lazy functions that return iterators, and you should use yield instead of return.</p>

<pre><code>def map(func, iterable):
    """One do by yourself map function"""
    results = []
    for item in iterable:
        results.append(func(item))
    return results

def gmap(func, iterable):
    for item in iterable:
        yield func(item)

def map2(func, iterable):
    """turning iterator into one list"""
    return list(gmap(func, iterable))

list1 = [1, 2, 3, 4, 5]
import math
def square(num):
    return math.pow(num, 2)
list2 = map(square, list1)
list3 = map2(square, list1)
</code></pre>

<h2>Decorators</h2>

<p>One decorator must return callables. Decorators that take extra arguments must return callables that return callables.<br/>
Ok, I am gonna talk a little bit more on this topic. first of all, why are we using decorator, do not repeat yourself, that is why, when you are doing some thing same over and over again, decorator is the right tool for you.</p>

<pre><code>def spam(func):
    def wrapper(*args, **kwargs):
        for i in range(10):
            func(*args, **kwargs)
    return wrapper

@spam  #syntactic sugar   talk = spam(talk)
def talk(word):
    """talk docstring"""
    print word
talk('fsp')
print talk.__doc__
</code></pre>

<p>It works fine, whenever you want to repeat a function for 10 times, you can use this decorator. Now here is the problem, what if I want to repeat 11 times, another decorator? No!!!</p>

<pre><code>def spam(repeats):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for i in range(repeats):
                func(*args, **kwargs)
        return wrapper
    return decorator

@spam(11)
def talk(word):
    print word
</code></pre>

<p>Pretty good by far, not enough though, we can see that talk function has one docstring, however it is lost for wrapper has no docstring, of course we can add it by <code>wrapper.__doc__ = func.__doc__</code>, however, what about name attribute of the function and we do not want to do that everytime we write a decorator, ok, think about it, what we are gonna need? We need one decorator, we need one decorator that return a wrapper which has everything the func shoud have. Ok, python provides us with that, so import it then.</p>

<pre><code>from functools import wraps
def spam(repeats):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for i in range(repeats):
                func(*args, **kwargs)
        return wrapper
    return decorator
</code></pre>

<p>Done!</p>

<h2>New-style class</h2>

<p>Classic classes and instances are separate types. In new-style class, the type of the instance is that class. Except for this, there are lots of new general mechanisms. <br/>
I will introduce a few things about new-style class here, and most of the features I am going to talk about is based on new-style class.</p>

<pre><code>class A():
    def met(self):
        print 'A.met'
class B(A):
    pass
class C(A):
    def met(self):
        print 'C.met'
class D(B, C):
    pass
d1 = D()
d1.met()
</code></pre>

<p>The result is gonna be &lsquo;A.met&rsquo; which is no what we want. So here is the thing, D is the child class of B and C, B and C inherit from A, the classic class follow a left-to-right and deep-first searching pattern when it is looking for a father attribute, so we have D &ndash; B &ndash; A &ndash; C &ndash; A, A is searched first, as a result, even we override the met method in C, python still use the met of A class. That is wrong, and with new-style class, no worries.</p>

<pre><code># new style class
class A1(object):
    def met(self):
        print 'A1.met'
class B1(A1):
    pass
class C1(A1):
    def met(self):
        print 'C1.met'
class D1(B1, C1):
    pass
d2 = D1()
d2.met()
</code></pre>

<p>We have &lsquo;C1.met&rsquo; now, the problem is what if C1 and B1 class both use <code>A1.met(self)</code> inside their met method, then we are going to get two &lsquo;A1.met&rsquo; ouput, we have super to deal with this.</p>

<pre><code>class A2(object):
    def met(self):
        print 'A2.met'
class B2(A2):
    def met(self):
        print 'B2.met'
        super(B2, self).met()
class C2(A2):
    def met(self):
        print 'C2.met'
        super(C2, self).met()
class D2(B2, C2):
    def met(self):
        print 'D2.met'
        super(D2, self).met()
d3 = D2()
d3.met()
</code></pre>

<p><em>To be continued…………</em></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">fengsp</span></span>

      








  


<time datetime="2013-07-30T14:51:00+08:00" pubdate data-updated="true">Jul 30<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/programming/'>programming</a>, <a class='category' href='/blog/categories/python/'>python</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://fengsp.github.io/blog/2013/07/30/something-about-python-part-i/" data-via="" data-counturl="http://fengsp.github.io/blog/2013/07/30/something-about-python-part-i/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/07/18/welcome-to-my-blog/" title="Previous Post: Welcome to my blog">&laquo; Welcome to my blog</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/07/30/something-about-python-part-i/">About Python: Part I</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/18/welcome-to-my-blog/">Welcome to My Blog</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - fengsp -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
